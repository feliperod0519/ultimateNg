npm i -g @angular/cli@latest
ng new my-app
node -v
npm -v

Ang 19 and higher
------------------
import { Component } from "@angular/core";

@Component(
    {
        selector: 'app-header',
        standalone: true,
        templateUrl: './header.component.html',
       
    })
export class HeaderComponent{}

Check in angular.json the assets in options
"assets": [
              "src/favicon.ico",
              "src/assets"
            ]
Otherwise images won't show

ng g c user

zone.js notifies Angular about user events, expired timers etc.
a way to update state since ang 2

signals since 16

Example (basic): 
Check C:\AutoFormation\Angular-Ultimate\LearningCode\02-Essentials\01-starting-project\01-starting-project\src\app\user

Signals are trackable data containers
input has to do w/signals
output not really

---
return this.users.find((user)=>user.id === this.selectedUserId)!;

The ! means you are ensuring angular no null value will be send over.

@Input() name?: string; means it can be null
or @Input() name: string | undefined; is equivalent
@Input({required:true}) name!: string; means you ensures angular no undefined

Another idea:
<app-tasks [name]="selectedUser?.name" />

type User ={id:string,name:string,avatar:string}
interface User {id:string,name:string,avatar:string}

@for (user of users; track user.id){
      <li>
        <app-user [id]="user.id" [avatar]="user.avatar" [name]="user.name" (select)="onSelectUser($event)" [user]="user"/>
      </li>
    }

@if (currentSelectedName){
    <app-userdetail [name]="currentSelectedName"></app-userdetail>
  }
  @else {
    <p id="fallback">Please select a user</p>
  }
  
@If and @for are available from 17

<app-userdetail *ngIf="currentSelectedName; else fallback" [name]="currentSelectedName"></app-userdetail>
    <ng-template #fallback>
      <p id="fallback">Please select a user</p>
    </ng-template>

Don't forget to add NgFor and NgIf in the imports because they are directives

----
When exporting types into separate files

import { type User } from './user.model'; The type is not mandatory but ok to do it

ngModel directive: "element enhancement" helps: extracting/changing user inputs.
directives don't have a template.

A Component is a directive w/templates.

<input type="text" id="title" name="title" [(ngModel)]="enteredTitle"/>
you need to register FormsModule will register NgModel:
import { Component, Output, EventEmitter } from '@angular/core';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-newtask',
  standalone: true,
  imports: [FormsModule],
  templateUrl: './newtask.component.html',
  styleUrl: './newtask.component.css'
})
export class NewtaskComponent {

Will update property on every keystroke.

----------------------
onAddNewTask(taskData:INewTaskData){
    this.tasks.unshift(
      {
        id: new Date().getTime().toString(),
        userId: this.userId,
        title: taskData.title,
        summary: taskData.summary,
        dueDate: taskData.date
      })
  }
unshift is somewhat like push

<app-card>...<app-card> by default the content is not wrapped.
The answer is: Content Projection
------
Pipes: output transformers
----
Services
inject() or constructor

constructor(){
        const tasks = localStorage.getItem('tasks');
        if (tasks){
            this.tasks = JSON.parse(tasks);
        }
    }
	
------------
Example (modules-old fashioned):
C:\AutoFormation\Angular-Ultimate\LearningCode\03-essentials-modules 

angular modules
backward compability
current version is like this:

@Component({
    selector: 'app-root',
    standalone: true,
    templateUrl: './app.component.html',
    styleUrl: './app.component.css',
    imports: [HeaderComponent, UserComponent, TasksComponent]
})

Angular modules make components available to each other

AppModule
AppComponent
HeaderComponent UserComponent TaskComponent
							  TaskModule
<19: Not setting standalone at all would give you a Module-based component.						  
Therefore, you should check your package.json file to see whether you're using Angular 19+ or not.			

AppModule

import { NgModule } from "@angular/core";
import { AppComponent } from "./app.component";
import { HeaderComponent } from "./header/header.component";
import { UserComponent } from "./user/user.component";
import { TasksComponent } from "./tasks/tasks.component";

@NgModule({
    declarations: [AppComponent, ], //declare and register standalone components(and directives) that will work together
    bootstrap: [AppComponent],
    imports: [HeaderComponent, UserComponent, TasksComponent]
})
export class AppModule{

}

declarations is for non-standalone
imports is for standalone components		  

Defining 2 possible types in an example w/ signals
  resultsDataSignal = signal<{
                              year: number,
                              interest: number,
                              valueEndOfYear: number,
                              annualInvestment: number,
                              totalInterest: number,
                              totalAmountInvested: number,
                            }[] | undefined>(undefined);
							
https://www.youtube.com/watch?v=n1a2eQ0Zyls
(signals)
ng new angular-tour-of-heroes
http://medium.com/@drissi.dalanda8/signals-in-angular-18-a-comprehensive-guide-with-examples-46b4a0c99ddd
https://blog.angular-university.io/angular-signal-components/

Instead of.
@Input() book: Book;

  ngOnChanges(changes: SimpleChanges) {
    if (changes[book]) {
      console.log("Book changed: ", 
         changes.book.currentValue);
    }
  }
We'll be using
constructor() {
    effect(() => {
      console.log("Book changed: ", this.book());
    });
  }
  
model()
A Model input is essentially a writeable input!

Model inputs allow us to specify a two-way data binding contract between the parent component and the child component.

Banana in a box is a shortcut for 

template:`<input ngModel [ngModel]="inputValue" (ngModelChange)="inputValue = $event">`
...
export class AppCompoenent{
	inputValue = '';
}

or

template:`<input ngModel [(ngModel)]="inputValue" >`

----------------

Debugging
Go to Ctrl+i (source)... there you have your code.
You can put checkpoints.
Add the angular dev tools extension

----------
Components and Templates
Separation of concerns
<app-dashboard-item [image]="{ src: 'status.png', alt:'A signal symbol'}" title="A signal symbol">
title w/o [] is possible because it's a string, alternatively [title]="'blah blah'" 

<ng-content></ng-content> place holder

Attributes selector:
@Component({
  selector: 'button[appButton]',
  standalone: true,
  imports: [],
  templateUrl: './button.component.html',
  styleUrl: './button.component.css'
})
This means any element button w/appButton attribute should be controlled by this.
or selector: 'button.button', means button with class button

ngProjectAs
<button>
    <span>
      <ng-content></ng-content>
    </span>
    <ng-content select="icon"></ng-content>
</button>
Usage:
<button appButton>Submit <span ngProjectAs="icon">⌲</span></button>

Fallback:
<button>
    <span>
      <ng-content></ng-content>
    </span>
    <ng-content select="icon">⌲</ng-content>
</button>
if you remove the projection it will use that

multi-element custom
<p>
    <label>{{label()}}</label>
    <ng-content select="input, textarea"></ng-content>
</p>

Reminder:
<div class="container" *ngIf="courses.length; else noCourses">
  <h1>All Courses</h1>
  ....
</div>  

<ng-template #noCourses>
  <h1>No courses available.</h1>
</ng-template>

ViewEncapsulation

import { Component, input, ViewEncapsulation } from '@angular/core';

@Component({
  selector: 'app-control',
  standalone: true,
  imports: [],
  templateUrl: './control.component.html',
  styleUrl: './control.component.css',
  encapsulation: ViewEncapsulation.None
})
export class ControlComponent {
  label = input.required<string>()
}
None means the CSS will come back to be global

Host elements

Host is the generic component simply decoreted by your markup (selector)
:host selector is special in css
is applied directly 

@Component({
  selector: 'app-control',
  standalone: true,
  imports: [],
  templateUrl: './control.component.html',
  styleUrl: './control.component.css',
  encapsulation: ViewEncapsulation.None,
  host: {
    class: 'control'
  }
})

will add class=ccontrol to app-control

Host Binding
import { Component, HostBinding, input, ViewEncapsulation } from '@angular/core';

@Component({
  selector: 'app-control',
  standalone: true,
  imports: [],
  templateUrl: './control.component.html',
  styleUrl: './control.component.css',
  encapsulation: ViewEncapsulation.None,
  // host: {
  //   class: 'control'
  // }
})
export class ControlComponent {
  @HostBinding('class') className = 'control';
  label = input.required<string>()
}
//it's now discourage use host property in conf instead

ElementRef
private el = inject(ElementRef);

  onClick(){
    console.log('Clicked!');
    console.log(this.el);
  }
 
Binding a class
<div [class.status]="currentStatus === 'online'">

An example
<p>Last 7 days</p>

      <div id="chart">
        @for (dataPoint of dummyTrafficData; track dataPoint.id) {
          <div [style.height]="(dataPoint.value / maxTraffic) * 100 + '%'"></div>
        }
      </div>

C:\AutoFormation\Angular-Ultimate\LearningCode\06-cmp-deep-dive\lifecycle-deep-dive-start\lifecycle-deep-dive-start

Execution order (First time)
1. Constructor
2. ngOnChanges
3. ngDoCheck
4.   ngAfterContentIni     ngAfterViewIni
5. ngAfterContentChecher   ngAfterViewChecked
6. <Rendering>
7. AfterRender

Execution order (Subsequent)
1. ngOnChanges
2. neDoCheck
3. ngAfterContentChecher ngAfterViewChecked
4. <Rendering>
5. AfterRender

ngOnChanges whenever the input values change
ngDoCheck runs a lot of time... don't put code here. Only advanced niche cases
View is template.
Content projected. <ng-content> 
F.ex: 

<h2>The Angular Component Lifecycle</h2>
<p>A component to demonstrate the Angular component lifecycle Hooks.</p>
<p>{{ text }}</p>
<ng-content></ng-content>

OnDestroy is old fashion, replace it by destroyRef
Check server-status

Template Variables
#WhatEver
That's actually a notation

import { Component, ElementRef, HostBinding, HostListener, input, ViewEncapsulation, inject } from '@angular/core';

@Component({
  selector: 'app-control',
  standalone: true,
  imports: [],
  templateUrl: './control.component.html',
  styleUrl: './control.component.css',
  encapsulation: ViewEncapsulation.None,
  host: {
    class: 'control',
    '(click)':'onClick()'
  }
})
export class ControlComponent {
  //@HostBinding('class') className = 'control'; //it's now discourage use host property in conf instead
  //@HostListener('click')= onClick(){console.log('Clicked!')}
  label = input.required<string>()

  private el = inject(ElementRef);

  onClick(){
    console.log('Clicked!');
    console.dir(this.el);
  }
}

Good example.

Check new-ticket.ts to see # and HTMLInput entries.

Template variables

ContentChild
As usual you can use old-fashioned
@ContentChild('input') private control?: ElementRef<HTMLInputElement | HTMLTextAreaElement>;//go where it is used. For example in new-ticket

Or a new version  
private control = contentChild<ElementRef<HTMLInputElement | HTMLTextAreaElement>>('input')

<form (ngSubmit)="onSubmit(titleInput,request.value)" #form>
    <app-control label="Title">
        <input name="title" id="title" #titleInput #input/> <!-- you can use [(ngModel)]-->
    </app-control>
    <app-control label="Request">
        <label>Request</label>
        <textarea name="request" id="request" rows="3" #request #input></textarea>
    </app-control>
    <p>
        <button appButton>Submit <span ngProjectAs="icon">⌲</span></button>
    </p>
</form>

Effects

import { Component, DestroyRef, OnDestroy, OnInit, effect, inject, signal } from '@angular/core';

@Component({
  selector: 'app-server-status',
  standalone: true,
  imports: [],
  templateUrl: './server-status.component.html',
  styleUrl: './server-status.component.css'
})
export class ServerStatusComponent implements OnInit, OnDestroy{
  //currentStatus: 'online' | 'offline' | 'unknown' = 'offline';
  currentStatus = signal<'online' | 'offline' | 'unknown'>('offline');
  private interval?: ReturnType<typeof setInterval>; //NodeJS.Timeout; <--- sometimes it doesn't work so replace it by ReturnType ...

  private destroyRef = inject(DestroyRef);

  constructor(){
    effect(()=>{
      console.log(this.currentStatus());
    })
    //it is here because it is not a subscription right away...
  }

  ngOnInit(): void {
    // this.interval = setInterval(()=>{
    //   const rnd = Math.random();
    //   if (rnd<0.5){
    //     this.currentStatus = 'online'
    //   }
    //   else if (rnd < 0.9){
    //     this.currentStatus = 'offline'
    //   }
    //   else{
    //     this.currentStatus = 'unknown'
    //   }
    // },5000);
    const interval = setInterval(()=>{
      const rnd = Math.random();
      if (rnd<0.5){
        //this.currentStatus = 'online'
        this.currentStatus.set('online')
      }
      else if (rnd < 0.9){
        this.currentStatus.set('offline')
      }
      else{
        this.currentStatus.set('unknown');
      }
    },5000);
    this.destroyRef.onDestroy(()=>{
      clearInterval(interval)
    })
  }

  ngOnDestroy(): void {
    clearInterval(this.interval);
  }

 
}

<!-- <div [class.status]="currentStatus === 'online'"> --> <!-- 1st method--> 
<div class="{ 
                status: true, 
                'status-online': currentStatus() === 'online',
                'status-offline': currentStatus() === 'offline',
                'status-unknown': currentStatus() === 'unknown'
            }"
      >
      @if (currentStatus() === 'online') {
        <p>Servers are online</p>
        <p>All systems are operational.</p>
      } @else if (currentStatus() === 'offline') {
        <p>Servers are offline</p>
        <p>Functionality should be restored soon.</p>
      } @else {
        <p>Server status is unknown</p>
        <p>Fetching server status failed.</p>
      }
</div>
<!-- If you ever need:
 [style.fontSize]="'64px'" -->
 
 Clean up effects example
 effect((onCleanup) => {
  const tasks = getTasks();
  const timer = setTimeout(() => {
    console.log(`Current number of tasks: ${tasks().length}`);
  }, 1000);
  onCleanup(() => {
    clearTimeout(timer);
  });
});

<div>
    <ul>
        @for (t of tickets; track t.id){
            <li>
                <app-ticket />
            </li>
        }
        @empty{
            <p>No tickets available</p>
        }
    </ul>
</div>


<div id="new-ticket">
    <app-new-ticket (add) = "onAdd($event)" />
</div>

Revisiting input - output

<div>
    <ul>
        @for (t of tickets; track t.id){
            <li>
                <app-ticket /> - {{ $first}} - {{$last}} - {{$even}} -  {{$count}}
            </li>
        }
        @empty{
            <p>No tickets available</p>
        }
    </ul>
</div>


<div id="new-ticket">
    <app-new-ticket (add) = "onAdd($event)" />
</div>


Check full example of output, update, etc in 
tickets and ticket

Custom 2-way binding
/c/AutoFormation/Angular-Ultimate/LearningCode/06-cmp-deep-dive/custom-2w-binding-starting-project/19-custom-2w-binding-starting-project

import { Component,input, output, Input, Output, EventEmitter, model } from '@angular/core';

@Component({
  selector: 'app-rect',
  standalone: true,
  imports: [],
  templateUrl: './rect.component.html',
  styleUrl: './rect.component.css',
})
export class RectComponent {
  // Todo: Implement custom two-way binding

  // size = input.required<{ width:string, height:string }>()
  // sizeChange = output<{ width:string, height:string }>(); //xxxChange is Mandatory

  // @Input({required:true})size!:{width:string, height:string};
  // @Output()sizeChange = new EventEmitter<{width:string, height:string}>(); //xxxChange is Mandatory

  size = model.required<{width:string, height:string}>();

  onReset() {
    this.size.set({width:'200', height:'100'})
    //this.sizeChange.emit({width:'200', height:'100'})
  }
}


DIRECTIVES
Enhacements foe elements.
Directives have no templates.
In other words: Components are directives w/ templates.
Check ng-cotent if you have a question.

C:\AutoFormation\Angular-Ultimate\LearningCode\07-directives-deep-dive\starting-project

Structural v. Attribute directive

Attribute like [(ngModel)] ---> Change the behavior
Structural like *ngIf --> Change the structure

Custom directives
safe-link.directive.ts

Injecting host elementref (advances)
private hostElementRef = inject<ElementRef<HTMLAnchorElement>>(ElementRef);

Full:
import { Directive, ElementRef, input, inject } from "@angular/core";


@Directive({ 
    selector: 'a[appSafeLink]',
    standalone: true,
    host: {
        '(click)':'onConfirmLeavePage($event)',
    }

})
export class SafeLinkDirective{
    
    queryParam = input('myapp')
    private hostElementRef = inject<ElementRef<HTMLAnchorElement>>(ElementRef);

    constructor(){
        console.log('SafeLink is active')
    }
    
    onConfirmLeavePage(event: MouseEvent){
        const wantsToLeave = window.open('Do you want to leave?');
        if (wantsToLeave){
            // const address = (event.target as HTMLAnchorElement).href;
            // (event.target as HTMLAnchorElement).href = address + '?from=' + this.queryParam;
            const address = this.hostElementRef.nativeElement.href;
            this.hostElementRef.nativeElement.href = address + '?from=' + this.queryParam;
            return;
        }
        event.preventDefault();
    }
}
//Alternatively you can use @HostListener instead of host in config object

Building Custom structural attribute

ng-template content will be eventually rendered. Prepare some markup.
example:

<main>
  <app-learning-resources />

  <hr />

  <app-auth />

  <!-- @if (isAdmin()){
    <p>Only admins should see</p>
  } -->
  
  <!-- <p *ngIf="isAdmin()">Only admins should see</p> -->
  <ng-template appAuth="admin">
    <p>Only admins should see</p>
  </ng-template>
</main>

TempleteRef and ViewContainerRef

@Directive({
  selector: '[appAuth]',
  standalone: true
})
export class AuthDirective {

  usetType = input.required<Permission>({alias:'appAuth'});
  private authService = inject(AuthService);
  private templateRef = inject(TemplateRef);
  private viewContainerRef = inject(ViewContainerRef);

  constructor() { 
    effect(()=>{
      console.log('su madre',this.usetType())
      if (this.authService.activePermission()===this.usetType()){
        console.log('SHOW ELEMENT');
        this.viewContainerRef.createEmbeddedView(this.templateRef)
      }
      else{
        console.log('DO NOT SHOW ELEMENT');
        this.viewContainerRef.clear();
      }
    })
  }

}

  <ng-template appAuth="admin">
    <p class="protected-content admin">Only admins should see</p>
  </ng-template>

  <p *appAuth="'user'" class="protected-content unauthenticated">Only users should see</p> <!-- also valid -->

  <p *appAuth="'guest'" class="protected-content authenticated">Only guest should see</p> <!-- also valid -->