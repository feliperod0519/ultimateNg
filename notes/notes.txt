npm i -g @angular/cli@latest
ng new my-app
node -v
npm -v

Ang 19 and higher
------------------
import { Component } from "@angular/core";

@Component(
    {
        selector: 'app-header',
        standalone: true,
        templateUrl: './header.component.html',
       
    })
export class HeaderComponent{}

Check in angular.json the assets in options
"assets": [
              "src/favicon.ico",
              "src/assets"
            ]
Otherwise images won't show

ng g c user

zone.js notifies Angular about user events, expired timers etc.
a way to update state since ang 2

signals since 16

Example (basic): 
Check C:\AutoFormation\Angular-Ultimate\LearningCode\02-Essentials\01-starting-project\01-starting-project\src\app\user

Signals are trackable data containers
input has to do w/signals
output not really

---
return this.users.find((user)=>user.id === this.selectedUserId)!;

The ! means you are ensuring angular no null value will be send over.

@Input() name?: string; means it can be null
or @Input() name: string | undefined; is equivalent
@Input({required:true}) name!: string; means you ensures angular no undefined

Another idea:
<app-tasks [name]="selectedUser?.name" />

type User ={id:string,name:string,avatar:string}
interface User {id:string,name:string,avatar:string}

@for (user of users; track user.id){
      <li>
        <app-user [id]="user.id" [avatar]="user.avatar" [name]="user.name" (select)="onSelectUser($event)" [user]="user"/>
      </li>
    }

@if (currentSelectedName){
    <app-userdetail [name]="currentSelectedName"></app-userdetail>
  }
  @else {
    <p id="fallback">Please select a user</p>
  }
  
@If and @for are available from 17

<app-userdetail *ngIf="currentSelectedName; else fallback" [name]="currentSelectedName"></app-userdetail>
    <ng-template #fallback>
      <p id="fallback">Please select a user</p>
    </ng-template>

Don't forget to add NgFor and NgIf in the imports because they are directives

----
When exporting types into separate files

import { type User } from './user.model'; The type is not mandatory but ok to do it

ngModel directive: "element enhancement" helps: extracting/changing user inputs.
directives don't have a template.

A Component is a directive w/templates.

<input type="text" id="title" name="title" [(ngModel)]="enteredTitle"/>
you need to register FormsModule will register NgModel:
import { Component, Output, EventEmitter } from '@angular/core';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-newtask',
  standalone: true,
  imports: [FormsModule],
  templateUrl: './newtask.component.html',
  styleUrl: './newtask.component.css'
})
export class NewtaskComponent {

Will update property on every keystroke.

----------------------
onAddNewTask(taskData:INewTaskData){
    this.tasks.unshift(
      {
        id: new Date().getTime().toString(),
        userId: this.userId,
        title: taskData.title,
        summary: taskData.summary,
        dueDate: taskData.date
      })
  }
unshift is somewhat like push

<app-card>...<app-card> by default the content is not wrapped.
The answer is: Content Projection
------
Pipes: output transformers
----
Services
inject() or constructor

constructor(){
        const tasks = localStorage.getItem('tasks');
        if (tasks){
            this.tasks = JSON.parse(tasks);
        }
    }
	
------------
Example (modules-old fashioned):
C:\AutoFormation\Angular-Ultimate\LearningCode\03-essentials-modules 

angular modules
backward compability
current version is like this:

@Component({
    selector: 'app-root',
    standalone: true,
    templateUrl: './app.component.html',
    styleUrl: './app.component.css',
    imports: [HeaderComponent, UserComponent, TasksComponent]
})

Angular modules make components available to each other

AppModule
AppComponent
HeaderComponent UserComponent TaskComponent
							  TaskModule
<19: Not setting standalone at all would give you a Module-based component.						  
Therefore, you should check your package.json file to see whether you're using Angular 19+ or not.			

AppModule

import { NgModule } from "@angular/core";
import { AppComponent } from "./app.component";
import { HeaderComponent } from "./header/header.component";
import { UserComponent } from "./user/user.component";
import { TasksComponent } from "./tasks/tasks.component";

@NgModule({
    declarations: [AppComponent, ], //declare and register standalone components(and directives) that will work together
    bootstrap: [AppComponent],
    imports: [HeaderComponent, UserComponent, TasksComponent]
})
export class AppModule{

}

declarations is for non-standalone
imports is for standalone components		  

Defining 2 possible types in an example w/ signals
  resultsDataSignal = signal<{
                              year: number,
                              interest: number,
                              valueEndOfYear: number,
                              annualInvestment: number,
                              totalInterest: number,
                              totalAmountInvested: number,
                            }[] | undefined>(undefined);
							
https://www.youtube.com/watch?v=n1a2eQ0Zyls
(signals)
ng new angular-tour-of-heroes
http://medium.com/@drissi.dalanda8/signals-in-angular-18-a-comprehensive-guide-with-examples-46b4a0c99ddd
https://blog.angular-university.io/angular-signal-components/

Instead of.
@Input() book: Book;

  ngOnChanges(changes: SimpleChanges) {
    if (changes[book]) {
      console.log("Book changed: ", 
         changes.book.currentValue);
    }
  }
We'll be using
constructor() {
    effect(() => {
      console.log("Book changed: ", this.book());
    });
  }
  
model()
A Model input is essentially a writeable input!

Model inputs allow us to specify a two-way data binding contract between the parent component and the child component.

Banana in a box is a shortcut for 

template:`<input ngModel [ngModel]="inputValue" (ngModelChange)="inputValue = $event">`
...
export class AppCompoenent{
	inputValue = '';
}

or

template:`<input ngModel [(ngModel)]="inputValue" >`

----------------

Debugging
Go to Ctrl+i (source)... there you have your code.
You can put checkpoints.
Add the angular dev tools extension

----------
Components and Templates
Separation of concerns
<app-dashboard-item [image]="{ src: 'status.png', alt:'A signal symbol'}" title="A signal symbol">
title w/o [] is possible because it's a string, alternatively [title]="'blah blah'" 

<ng-content></ng-content> place holder

Attributes selector:
@Component({
  selector: 'button[appButton]',
  standalone: true,
  imports: [],
  templateUrl: './button.component.html',
  styleUrl: './button.component.css'
})
This means any element button w/appButton attribute should be controlled by this.
or selector: 'button.button', means button with class button

ngProjectAs
<button>
    <span>
      <ng-content></ng-content>
    </span>
    <ng-content select="icon"></ng-content>
</button>
Usage:
<button appButton>Submit <span ngProjectAs="icon">⌲</span></button>

Fallback:
<button>
    <span>
      <ng-content></ng-content>
    </span>
    <ng-content select="icon">⌲</ng-content>
</button>
if you remove the projection it will use that

multi-element custom
<p>
    <label>{{label()}}</label>
    <ng-content select="input, textarea"></ng-content>
</p>

Reminder:
<div class="container" *ngIf="courses.length; else noCourses">
  <h1>All Courses</h1>
  ....
</div>  

<ng-template #noCourses>
  <h1>No courses available.</h1>
</ng-template>

ViewEncapsulation

import { Component, input, ViewEncapsulation } from '@angular/core';

@Component({
  selector: 'app-control',
  standalone: true,
  imports: [],
  templateUrl: './control.component.html',
  styleUrl: './control.component.css',
  encapsulation: ViewEncapsulation.None
})
export class ControlComponent {
  label = input.required<string>()
}
None means the CSS will come back to be global

Host elements

Host is the generic component simply decoreted by your markup (selector)
:host selector is special in css
is applied directly 

@Component({
  selector: 'app-control',
  standalone: true,
  imports: [],
  templateUrl: './control.component.html',
  styleUrl: './control.component.css',
  encapsulation: ViewEncapsulation.None,
  host: {
    class: 'control'
  }
})

will add class=ccontrol to app-control

Host Binding
import { Component, HostBinding, input, ViewEncapsulation } from '@angular/core';

@Component({
  selector: 'app-control',
  standalone: true,
  imports: [],
  templateUrl: './control.component.html',
  styleUrl: './control.component.css',
  encapsulation: ViewEncapsulation.None,
  // host: {
  //   class: 'control'
  // }
})
export class ControlComponent {
  @HostBinding('class') className = 'control';
  label = input.required<string>()
}
//it's now discourage use host property in conf instead

ElementRef
private el = inject(ElementRef);

  onClick(){
    console.log('Clicked!');
    console.log(this.el);
  }
 
Binding a class
<div [class.status]="currentStatus === 'online'">

An example
<p>Last 7 days</p>

      <div id="chart">
        @for (dataPoint of dummyTrafficData; track dataPoint.id) {
          <div [style.height]="(dataPoint.value / maxTraffic) * 100 + '%'"></div>
        }
      </div>

C:\AutoFormation\Angular-Ultimate\LearningCode\06-cmp-deep-dive\lifecycle-deep-dive-start\lifecycle-deep-dive-start

Execution order (First time)
1. Constructor
2. ngOnChanges
3. ngDoCheck
4.   ngAfterContentIni     ngAfterViewIni
5. ngAfterContentChecher   ngAfterViewChecked
6. <Rendering>
7. AfterRender

Execution order (Subsequent)
1. ngOnChanges
2. neDoCheck
3. ngAfterContentChecher ngAfterViewChecked
4. <Rendering>
5. AfterRender

ngOnChanges whenever the input values change
ngDoCheck runs a lot of time... don't put code here. Only advanced niche cases
View is template.
Content projected. <ng-content> 
F.ex: 

<h2>The Angular Component Lifecycle</h2>
<p>A component to demonstrate the Angular component lifecycle Hooks.</p>
<p>{{ text }}</p>
<ng-content></ng-content>

OnDestroy is old fashion, replace it by destroyRef
Check server-status

Template Variables
#WhatEver
That's actually a notation

import { Component, ElementRef, HostBinding, HostListener, input, ViewEncapsulation, inject } from '@angular/core';

@Component({
  selector: 'app-control',
  standalone: true,
  imports: [],
  templateUrl: './control.component.html',
  styleUrl: './control.component.css',
  encapsulation: ViewEncapsulation.None,
  host: {
    class: 'control',
    '(click)':'onClick()'
  }
})
export class ControlComponent {
  //@HostBinding('class') className = 'control'; //it's now discourage use host property in conf instead
  //@HostListener('click')= onClick(){console.log('Clicked!')}
  label = input.required<string>()

  private el = inject(ElementRef);

  onClick(){
    console.log('Clicked!');
    console.dir(this.el);
  }
}

Good example.

Check new-ticket.ts to see # and HTMLInput entries.

Template variables

ContentChild
As usual you can use old-fashioned
@ContentChild('input') private control?: ElementRef<HTMLInputElement | HTMLTextAreaElement>;//go where it is used. For example in new-ticket

Or a new version  
private control = contentChild<ElementRef<HTMLInputElement | HTMLTextAreaElement>>('input')

<form (ngSubmit)="onSubmit(titleInput,request.value)" #form>
    <app-control label="Title">
        <input name="title" id="title" #titleInput #input/> <!-- you can use [(ngModel)]-->
    </app-control>
    <app-control label="Request">
        <label>Request</label>
        <textarea name="request" id="request" rows="3" #request #input></textarea>
    </app-control>
    <p>
        <button appButton>Submit <span ngProjectAs="icon">⌲</span></button>
    </p>
</form>

Effects

import { Component, DestroyRef, OnDestroy, OnInit, effect, inject, signal } from '@angular/core';

@Component({
  selector: 'app-server-status',
  standalone: true,
  imports: [],
  templateUrl: './server-status.component.html',
  styleUrl: './server-status.component.css'
})
export class ServerStatusComponent implements OnInit, OnDestroy{
  //currentStatus: 'online' | 'offline' | 'unknown' = 'offline';
  currentStatus = signal<'online' | 'offline' | 'unknown'>('offline');
  private interval?: ReturnType<typeof setInterval>; //NodeJS.Timeout; <--- sometimes it doesn't work so replace it by ReturnType ...

  private destroyRef = inject(DestroyRef);

  constructor(){
    effect(()=>{
      console.log(this.currentStatus());
    })
    //it is here because it is not a subscription right away...
  }

  ngOnInit(): void {
    // this.interval = setInterval(()=>{
    //   const rnd = Math.random();
    //   if (rnd<0.5){
    //     this.currentStatus = 'online'
    //   }
    //   else if (rnd < 0.9){
    //     this.currentStatus = 'offline'
    //   }
    //   else{
    //     this.currentStatus = 'unknown'
    //   }
    // },5000);
    const interval = setInterval(()=>{
      const rnd = Math.random();
      if (rnd<0.5){
        //this.currentStatus = 'online'
        this.currentStatus.set('online')
      }
      else if (rnd < 0.9){
        this.currentStatus.set('offline')
      }
      else{
        this.currentStatus.set('unknown');
      }
    },5000);
    this.destroyRef.onDestroy(()=>{
      clearInterval(interval)
    })
  }

  ngOnDestroy(): void {
    clearInterval(this.interval);
  }

 
}

<!-- <div [class.status]="currentStatus === 'online'"> --> <!-- 1st method--> 
<div class="{ 
                status: true, 
                'status-online': currentStatus() === 'online',
                'status-offline': currentStatus() === 'offline',
                'status-unknown': currentStatus() === 'unknown'
            }"
      >
      @if (currentStatus() === 'online') {
        <p>Servers are online</p>
        <p>All systems are operational.</p>
      } @else if (currentStatus() === 'offline') {
        <p>Servers are offline</p>
        <p>Functionality should be restored soon.</p>
      } @else {
        <p>Server status is unknown</p>
        <p>Fetching server status failed.</p>
      }
</div>
<!-- If you ever need:
 [style.fontSize]="'64px'" -->
 
 Clean up effects example
 effect((onCleanup) => {
  const tasks = getTasks();
  const timer = setTimeout(() => {
    console.log(`Current number of tasks: ${tasks().length}`);
  }, 1000);
  onCleanup(() => {
    clearTimeout(timer);
  });
});

<div>
    <ul>
        @for (t of tickets; track t.id){
            <li>
                <app-ticket />
            </li>
        }
        @empty{
            <p>No tickets available</p>
        }
    </ul>
</div>


<div id="new-ticket">
    <app-new-ticket (add) = "onAdd($event)" />
</div>

Revisiting input - output

<div>
    <ul>
        @for (t of tickets; track t.id){
            <li>
                <app-ticket /> - {{ $first}} - {{$last}} - {{$even}} -  {{$count}}
            </li>
        }
        @empty{
            <p>No tickets available</p>
        }
    </ul>
</div>


<div id="new-ticket">
    <app-new-ticket (add) = "onAdd($event)" />
</div>


Check full example of output, update, etc in 
tickets and ticket

Custom 2-way binding
/c/AutoFormation/Angular-Ultimate/LearningCode/06-cmp-deep-dive/custom-2w-binding-starting-project/19-custom-2w-binding-starting-project

import { Component,input, output, Input, Output, EventEmitter, model } from '@angular/core';

@Component({
  selector: 'app-rect',
  standalone: true,
  imports: [],
  templateUrl: './rect.component.html',
  styleUrl: './rect.component.css',
})
export class RectComponent {
  // Todo: Implement custom two-way binding

  // size = input.required<{ width:string, height:string }>()
  // sizeChange = output<{ width:string, height:string }>(); //xxxChange is Mandatory

  // @Input({required:true})size!:{width:string, height:string};
  // @Output()sizeChange = new EventEmitter<{width:string, height:string}>(); //xxxChange is Mandatory

  size = model.required<{width:string, height:string}>();

  onReset() {
    this.size.set({width:'200', height:'100'})
    //this.sizeChange.emit({width:'200', height:'100'})
  }
}


DIRECTIVES
Enhacements foe elements.
Directives have no templates.
In other words: Components are directives w/ templates.
Check ng-cotent if you have a question.

C:\AutoFormation\Angular-Ultimate\LearningCode\07-directives-deep-dive\starting-project

Structural v. Attribute directive

Attribute like [(ngModel)] ---> Change the behavior
Structural like *ngIf --> Change the structure

Custom directives
safe-link.directive.ts

Injecting host elementref (advances)
private hostElementRef = inject<ElementRef<HTMLAnchorElement>>(ElementRef);

Full:
import { Directive, ElementRef, input, inject } from "@angular/core";


@Directive({ 
    selector: 'a[appSafeLink]',
    standalone: true,
    host: {
        '(click)':'onConfirmLeavePage($event)',
    }

})
export class SafeLinkDirective{
    
    queryParam = input('myapp')
    private hostElementRef = inject<ElementRef<HTMLAnchorElement>>(ElementRef);

    constructor(){
        console.log('SafeLink is active')
    }
    
    onConfirmLeavePage(event: MouseEvent){
        const wantsToLeave = window.open('Do you want to leave?');
        if (wantsToLeave){
            // const address = (event.target as HTMLAnchorElement).href;
            // (event.target as HTMLAnchorElement).href = address + '?from=' + this.queryParam;
            const address = this.hostElementRef.nativeElement.href;
            this.hostElementRef.nativeElement.href = address + '?from=' + this.queryParam;
            return;
        }
        event.preventDefault();
    }
}
//Alternatively you can use @HostListener instead of host in config object

Building Custom structural attribute

ng-template content will be eventually rendered. Prepare some markup.
example:

<main>
  <app-learning-resources />

  <hr />

  <app-auth />

  <!-- @if (isAdmin()){
    <p>Only admins should see</p>
  } -->
  
  <!-- <p *ngIf="isAdmin()">Only admins should see</p> -->
  <ng-template appAuth="admin">
    <p>Only admins should see</p>
  </ng-template>
</main>

TempleteRef and ViewContainerRef

@Directive({
  selector: '[appAuth]',
  standalone: true
})
export class AuthDirective {

  usetType = input.required<Permission>({alias:'appAuth'});
  private authService = inject(AuthService);
  private templateRef = inject(TemplateRef);
  private viewContainerRef = inject(ViewContainerRef);

  constructor() { 
    effect(()=>{
      console.log('su madre',this.usetType())
      if (this.authService.activePermission()===this.usetType()){
        console.log('SHOW ELEMENT');
        this.viewContainerRef.createEmbeddedView(this.templateRef)
      }
      else{
        console.log('DO NOT SHOW ELEMENT');
        this.viewContainerRef.clear();
      }
    })
  }

}

  <ng-template appAuth="admin">
    <p class="protected-content admin">Only admins should see</p>
  </ng-template>

  <p *appAuth="'user'" class="protected-content unauthenticated">Only users should see</p> <!-- also valid -->

  <p *appAuth="'guest'" class="protected-content authenticated">Only guest should see</p> <!-- also valid -->
  
  Pipes
  
  /c/AutoFormation/Angular-Ultimate/LearningCode/08-pipes-deep-dive/starting-project/01-starting-project
  
  pure and impure pipes-deep-dive/starting-project/01-starting-project
  
  Services and Dependency injections
  
  To share logic and data.
  /c/AutoFormation/Angular-Ultimate/LearningCode/09-services-deep-dive/starting-project/01-starting-project
  
import { Component, inject, signal, computed } from '@angular/core';

import { TaskItemComponent } from './task-item/task-item.component';
import { TaskService } from '../task.service';

@Component({
  selector: 'app-tasks-list',
  standalone: true,
  templateUrl: './tasks-list.component.html',
  styleUrl: './tasks-list.component.css',
  imports: [TaskItemComponent],
})
export class TasksListComponent {
  private taskService = inject(TaskService);
  private selectedFilter = signal<string>('all');
  
  tasks = computed(()=> {
    switch(this.selectedFilter()){
      case 'all':
        return this.taskService.allTasks();
      case 'open':
        return this.taskService.allTasks().filter(t=>t.status==='OPEN');
      case 'in-progress':
        return this.taskService.allTasks().filter(t=>t.status==='IN_PROGRESS');
      case 'done':
        return this.taskService.allTasks().filter(t=>t.status==='DONE');
      default:
        return this.taskService.allTasks();
    }
  })

  //tasks are depending from a selectedFilter which it is a signal. selectedFilter has been modified. Tasks is a signal.
  
  onChangeTasksFilter(filter: string) {
    this.selectedFilter.set(filter);
  }
}

Element injector (not for injecting a service inside a service)
Check the logging example

Injector dev tools
Check the angular add on on browser. it has an injector feature.

--------------------
Change detection

/c/AutoFormation/Angular-Ultimate/LearningCode/10-change-detection/starting-project/01-starting-project

Zone.js notifies Angular about user events, expired timers, etc...

Angular checks all template bindings for changes.
All components are visited twice.
If the 1st and 2nd do not coincide, you will get an "ExpressionChangedAfterItHasBeenCheckedError" exception.

ngZone

import { Component, OnInit, signal,inject, NgZone } from '@angular/core';

import { InfoMessageComponent } from '../info-message/info-message.component';

@Component({
  selector: 'app-counter',
  standalone: true,
  templateUrl: './counter.component.html',
  styleUrl: './counter.component.css',
  imports: [InfoMessageComponent],
})
export class CounterComponent implements OnInit {
  private zone = inject(NgZone);
  count = signal(0);

  ngOnInit(): void {
    setTimeout(()=>{
      this.count.set(0);
    },4000);

    //opt-out Zone.js (ng's change detection)
    this.zone.runOutsideAngular(()=>{
      setTimeout(()=>{
        console.log('Timer expired!');
      },5000);  
    })
    // setTimeout(()=>{
    //   console.log('Timer expired!');
    // },5000);  
    //Los 2 timers generan que zone se ejecute 2 veces a pesar que el 2do timer no tiene nada que ver.
    //ngZone helps to avoid zone pollution
  }

  //Los 2 timers generan que zone se ejecute 2 veces a pesar que el 2do timer no tiene nada que ver.
  //ngZone

  get debugOutput() {
    console.log('[Counter] "debugOutput" binding re-evaluated.');
    return 'Counter Component Debug Output';
  }

  onDecrement() {
    this.count.update((prevCount) => prevCount - 1);
  }

  onIncrement() {
    this.count.update((prevCount) => prevCount + 1);
  }
}

OnPush Strategy

import { ChangeDetectionStrategy, Component, signal } from '@angular/core';

import { MessagesListComponent } from './messages-list/messages-list.component';
import { NewMessageComponent } from './new-message/new-message.component';

@Component({
  selector: 'app-messages',
  standalone: true,
  templateUrl: './messages.component.html',
  styleUrl: './messages.component.css',
  imports: [MessagesListComponent, NewMessageComponent],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class MessagesComponent {
  messages = signal<string[]>([]);

  get debugOutput() {
    console.log('[Messages] "debugOutput" binding re-evaluated.');
    return 'Messages Component Debug Output';
  }

  onAddMessage(message: string) {
    this.messages.update((oldMessages) => [...oldMessages, message]);
  }
}

ONPush & Signals

(before | sync)
---
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class MessagesService {
  messages$ = new BehaviorSubject<string[]>([]);
  private messages: string[] = [];
  get allMessages() {
    return [...this.messages];
  }

  addMessage(message: string) {
    this.messages = [...this.messages, message];
    this.messages$.next([...this.messages]);
  }
}
+++++++++++++++
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  DestroyRef,
  OnInit,
  inject,
} from '@angular/core';

import { MessagesService } from '../messages.services'

@Component({
  selector: 'app-messages-list',
  standalone: true,
  templateUrl: './messages-list.component.html',
  styleUrl: './messages-list.component.css',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class MessagesListComponent implements OnInit {
  private messagesService = inject(MessagesService);
  private cdRef = inject(ChangeDetectorRef);
  private destroyRef = inject(DestroyRef);

  messages: string[] = [];

  ngOnInit() {
    const subscription = this.messagesService.messages$.subscribe((messages) => {
      this.messages = messages;
      this.cdRef.markForCheck();
    });
    this.destroyRef.onDestroy(() => {
      subscription.unsubscribe();
    });
  }

  get debugOutput() {
    console.log('[MessagesList] "debugOutput" binding re-evaluated.');
    return 'MessagesList Component Debug Output';
  }
}
++++
<ul>
  @for (message of messages; track message) {
    <li>{{ message }}</li>
  }
</ul>

<p class="debug-output">{{ debugOutput }}</p>

OBSERVABLES

import { Component, DestroyRef, OnInit, inject } from '@angular/core';
import { interval } from 'rxjs'; 

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html'
})
export class AppComponent implements OnInit {

  private destroyRef = inject(DestroyRef)

  ngOnInit(): void {
    const subscription = interval(1000).subscribe({
      next: (val)=>console.log(val)
    })
    this.destroyRef.onDestroy(()=>{
      subscription.unsubscribe();
    })
  }
}

Signals vs. observables comparisson

import { Component, DestroyRef, OnInit, effect, inject, signal } from '@angular/core';
import { interval, map } from 'rxjs'; 

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html'
})
export class AppComponent implements OnInit {

  private destroyRef = inject(DestroyRef)
  clickCount = signal(0);

  constructor(){
    effect(()=>{
      console.log(`Clicked button ${this.clickCount()} times `)
    })
  }

  ngOnInit(): void {
    const subscription = interval(1000).pipe(
      map((val)=>val*2)      
    ).subscribe({
      next: (val)=>console.log(val)
    })
    this.destroyRef.onDestroy(()=>{
      subscription.unsubscribe();
    })
  }

  onClick(){
    this.clickCount.update(prevCount => prevCount + 1)
  }
}

For instance in services instead of BehaviorSubject you can use signals.
A data stream coming from external or very specific you can use observables;

You could use setInterval instead of rxjs interval
constructor(){
    setInterval(()=>{
      this.interval.update(pint=>pint+1)
    })
	...
	
For the click of the example

doubleInterval = (computed(()=>this.interval()*2))

Observables will start in the event of subscriber whereas signals-in-angular-18-a-comprehensive-guide-with-examples-46b4a0c99ddd
Signal can be read wherever.

CONCLUSION:
Observables are good for events and streamed data
Signals for managing app state.

Converting Signals to Obsevables (and viceversa)

import { Component, DestroyRef, OnInit, computed, effect, inject, signal } from '@angular/core';
import { interval, map } from 'rxjs'; 
import { toObservable, toSignal } from '@angular/core/rxjs-interop';

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html'
})
export class AppComponent implements OnInit {

  private destroyRef = inject(DestroyRef)
  clickCount = signal(0);

  clickCount$ = toObservable(this.clickCount); //pass the unexecuted symbol to observable

  interval$ = interval(1000); //convert to signal
  intervalSignal = toSignal(this.interval$,{ initialValue: 0 }); //now you can use in effect or compute or event in interpolation (check template file)
  //if you use toSignal no clean up is necessary

  //for the click in signals
  // doubleInterval = (computed(()=>this.interval()*2))

  constructor(){
    effect(()=>{
      console.log(`Clicked button ${this.clickCount()} times `)
    })

    //instead of using an effect to listen  (when you convert signal to Observable)
    //use the subscriber in ngOnlint
  }

  ngOnInit(): void {

    // setInterval(()=>{
    //   this.interval.update(pint=>pint+1)
    // })

    const subscription = interval(1000).pipe(
      map((val)=>val*2)      
    ).subscribe({
      next: (val)=>console.log(val)
    })
    this.destroyRef.onDestroy(()=>{
      subscription.unsubscribe();
    })

    const subs2 =this.clickCount$.subscribe({
      next: (val) => console.log(`Clicked button ${this.clickCount()} times `)
    })
    this.destroyRef.onDestroy(()=>{
      subs2.unsubscribe();
    })
  }

  onClick(){
    this.clickCount.update(prevCount => prevCount + 1)
  }
}

<img src="rxjs-logo.png" alt="The RxJS logo" />
<h1>Understanding RxJS & Observables</h1>
<p>Working with "Streams of Data".</p>

<p>
  <button (click)="onClick()">Click</button>
</p>
<p>
  {{clickCount()}}
</p>
<p>
  {{intervalSignal()}} <!-- subjects have initial values but not observables, signals always have initial values-->
</p>

Building a new observable from the scratch

import { Component, DestroyRef, OnInit, computed, effect, inject, signal } from '@angular/core';
import { interval, map, Observable } from 'rxjs'; 
import { toObservable, toSignal } from '@angular/core/rxjs-interop';

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html'
})
export class AppComponent implements OnInit {

  private destroyRef = inject(DestroyRef)
  clickCount = signal(0);

  clickCount$ = toObservable(this.clickCount); //pass the unexecuted symbol to observable

  interval$ = interval(1000); //convert to signal
  intervalSignal = toSignal(this.interval$,{ initialValue: 0 }); //now you can use in effect or compute or event in interpolation (check template file)
  //if you use toSignal no clean up is necessary

  //for the click in signals
  // doubleInterval = (computed(()=>this.interval()*2))
  private customInterval$ = new Observable((subscriber)=>{
    setInterval(()=>{
      console.log('emiting new value');
      subscriber.next({ message: 'new value'});
    },2500)
  })

  constructor(){
    effect(()=>{
      console.log(`Clicked button ${this.clickCount()} times `)
    })

    //instead of using an effect to listen  (when you convert signal to Observable)
    //use the subscriber in ngOnlint
  }

  ngOnInit(): void {

    // setInterval(()=>{
    //   this.interval.update(pint=>pint+1)
    // })

    this.customInterval$.subscribe({
      next: (val) => console.log(val)
    })

    const subscription = interval(1000).pipe(
      map((val)=>val*2)      
    ).subscribe({
      next: (val)=>console.log(val)
    })
    this.destroyRef.onDestroy(()=>{
      subscription.unsubscribe();
    })

    const subs2 =this.clickCount$.subscribe({
      next: (val) => console.log(`Clicked button ${this.clickCount()} times `)
    })
    this.destroyRef.onDestroy(()=>{
      subs2.unsubscribe();
    })
  }

  onClick(){
    this.clickCount.update(prevCount => prevCount + 1)
  }
}

CREATING CUSTOM INTERVAL

private customInterval$ = new Observable((subscriber)=>{
    let timesExecuted = 0;
    const interval = setInterval(()=>{
      if (timesExecuted > 3){
        clearInterval(interval);
        subscriber.complete();
        return;
      }
      console.log('emiting new value');
      subscriber.next({ message: 'new value'});
      timesExecuted++;
    },2500)
  })

.....

ngOnInit(): void {

    // setInterval(()=>{
    //   this.interval.update(pint=>pint+1)
    // })

    this.customInterval$.subscribe({
      next: (val) => console.log(val),
      complete: () => console.log('completed!')
    })


BackEnd HTTP Requests

/c/AutoFormation/Angular-Ultimate/LearningCode/12-http/starting-project/01-starting-project-End
for backend: /c/AutoFormation/Angular-Ultimate/LearningCode/12-http/starting-project/01-starting-project/backend

import { Injectable, inject, signal } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { catchError, map, throwError, tap } from 'rxjs';

import { Place } from './place.model';

@Injectable({
  providedIn: 'root',
})
export class PlacesService {
  private httpClient = inject(HttpClient);
  private userPlaces = signal<Place[]>([]);

  loadedUserPlaces = this.userPlaces.asReadonly();

  loadAvailablePlaces() {
    return this.fetchPlaces(
      'http://localhost:3000/places',
      'Something went wrong fetching the available places. Please try again later.'
    );
  }

  loadUserPlaces() {
    return this.fetchPlaces(
      'http://localhost:3000/user-places',
      'Something went wrong fetching your favorite places. Please try again later.'
    ).pipe(
      tap({
        next: (userPlaces) => this.userPlaces.set(userPlaces),
      })
    );
  }

  addPlaceToUserPlaces(place:Place) {
    this.userPlaces.update(prevplaces => [...prevplaces, place])
    return this.httpClient.put('http://localhost:3000/user-places', {
      placeId: place.id,
    });
  }

  removeUserPlace(place: Place) {}

  private fetchPlaces(url: string, errorMessage: string) {
    return this.httpClient.get<{ places: Place[] }>(url).pipe(
      map((resData) => resData.places),
      catchError((error) => {
        console.log(error);
        return throwError(() => new Error(errorMessage));
      })
    );
  }
}

You can use subjects or signals as a mechanism of interprocess communication

Optimistic updating

import { Injectable, inject, signal } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { catchError, map, throwError, tap } from 'rxjs';

import { Place } from './place.model';

@Injectable({
  providedIn: 'root',
})
export class PlacesService {
  private httpClient = inject(HttpClient);
  private userPlaces = signal<Place[]>([]);

  loadedUserPlaces = this.userPlaces.asReadonly();

  loadAvailablePlaces() {
    return this.fetchPlaces(
      'http://localhost:3000/places',
      'Something went wrong fetching the available places. Please try again later.'
    );
  }

  loadUserPlaces() {
    return this.fetchPlaces(
      'http://localhost:3000/user-places',
      'Something went wrong fetching your favorite places. Please try again later.'
    ).pipe(
      tap({
        next: (userPlaces) => this.userPlaces.set(userPlaces),
      })
    );
  }

  addPlaceToUserPlaces(place: Place) {
    const prevPlaces = this.userPlaces();

    if (!prevPlaces.some((p) => p.id === place.id)) {
      this.userPlaces.set([...prevPlaces, place]);
    }

    return this.httpClient
      .put('http://localhost:3000/user-places', {
        placeId: place.id,
      })
      .pipe(
        catchError((error) => {
          this.userPlaces.set(prevPlaces);
          return throwError(() => new Error('Failed to store selected place.'));
        })
      );
  }

  removeUserPlace(place: Place) {}

  private fetchPlaces(url: string, errorMessage: string) {
    return this.httpClient.get<{ places: Place[] }>(url).pipe(
      map((resData) => resData.places),
      catchError((error) => {
        console.log(error);
        return throwError(() => new Error(errorMessage));
      })
    );
  }
}

Interceptors

import { bootstrapApplication } from '@angular/platform-browser';
import { HttpHandler, HttpHandlerFn, HttpRequest, provideHttpClient, withInterceptors } from '@angular/common/http';

import { bootstrapApplication } from '@angular/platform-browser';
import { HttpEventType, HttpHandler, HttpHandlerFn, HttpRequest, provideHttpClient, withInterceptors } from '@angular/common/http';

import { AppComponent } from './app/app.component';
import { tap } from 'rxjs';

function loggingInterceptor(request: HttpRequest<unknown>, next: HttpHandlerFn){
  // const req = request.clone({
  //   headers.headers.set('X-DEBUG','TESTING')
  // })
  
  console.log('[Outgoing Request]');
  console.log(request);
  return next(request).pipe(
    tap({
      next: event => {
        if (event.type === HttpEventType.Response){
          console.log('[Incoming Response]');
          console.log(event.status);
          console.log(event.body);
        }
      }
    })
  );
}


bootstrapApplication(AppComponent, {
  providers: [provideHttpClient(withInterceptors([loggingInterceptor]))]
}).catch((err) => console.error(err));


Besides defining HTTP interceptors as functions (which is the modern, recommended way of doing it), you can also define HTTP interceptors via classes.

For example, the loggingInterceptor from the previous lecture could be defined like this (when using this class-based approach):

import {
  HttpEvent,
  HttpHandler,
  HttpInterceptor,
  HttpRequest,
} from '@angular/common/http';
import { Observable } from 'rxjs';
 
@Injectable()
class LoggingInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<unknown>, handler: HttpHandler): Observable<HttpEvent<any>> {
    console.log('Request URL: ' + req.url);
    return handler.handle(req);
  }
}
An interceptor defined like this, must be provided in a different way than before though.

Instead of providing it like this:

providers: [
  provideHttpClient(
    withInterceptors([loggingInterceptor]),
  )
],
You now must use withInterceptorsFromDi() and set up a custom provider, like this:

providers: [
  provideHttpClient(
    withInterceptorsFromDi()
  ),
  { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }
]

HANDLING FormS

/c/AutoFormation/Angular-Ultimate/LearningCode/13-forms/starting-project/01-starting-project

Template Driven / Reactive FormS

TD: Easy to get started, complex logic can be tricky
RF: more verbose, complex forms imp is easier.

ngModel w/o 2-way binding

ngModel registers object w/ANG

Template driven:

<form #myForm="ngForm" (ngSubmit)="onSubmit(myForm)">
  <h2>Login</h2>

  <div class="control-row">
    <div class="control no-margin">
      <label for="email">Email</label>
      <input id="email" type="email" name="email" ngModel />
    </div>

    <div class="control no-margin">
      <label for="password">Password</label>
      <input id="password" type="password" name="password" ngModel />
    </div>

    <button class="button">Login</button>
  </div>
</form>

import { Component } from '@angular/core';
import { FormsModule, NgForm } from '@angular/forms';

@Component({
  selector: 'app-login',
  standalone: true,
  templateUrl: './login.component.html',
  styleUrl: './login.component.css',
  imports: [FormsModule]
})
export class LoginComponent {

  onSubmit(form: NgForm){
    console.log(form);
  }
}

<form #myForm="ngForm" (ngSubmit)="onSubmit(myForm)">
  <h2>Login</h2>

  <div class="control-row">
    <div class="control no-margin">
      <label for="email">Email</label>
      <input id="email" type="email" 
             name="email" required email 
             ngModel #email="ngModel" /> <!--[(ngModel)]="email"-->
    </div>

    <div class="control no-margin">
      <label for="password">Password</label>
      <input id="password" type="password" name="password" 
            ngModel required minlength="6" #password="ngModel"/>
    </div>

    <button class="button">Login</button>
  </div>

  <!-- @if (myForm.form.controls['email'].touched && myForm.form.controls['password'].touched && myForm.form.invalid){
    <p class="control-error">
      Invalid values detected. Please check your input.
    </p>
  } -->
  <!-- myForm.form.controls['email'].touched won't work because controls are not yet created  -->
   <!-- use template variables instead-->
   @if (email.touched && password.touched && myForm.form.invalid){
    <p class="control-error">
      Invalid values detected. Please check your input.
    </p>
  }


</form>

(STYLES)
.control:has(.ng-invalid.ng-touched.ng-dirty) label {
  color: #f98b75;
}

input.ng-invalid.ng-touched.ng-dirty {
  background-color: #fbdcd6;
  border-color: #f84e2c;
}

++++++++

  private form = viewChild.required<NgForm>('myForm');
  private destroyRef = inject(DestroyRef);

  constructor(){
    //We are using afternextRender because angular creates the form because is Template driven
    afterNextRender(()=>{
      const savedForm = window.localStorage.getItem('saved-login-form');
      if (savedForm){
        const loadedFormData = JSON.parse(savedForm);
        const savedEmail = loadedFormData.email;
        //this.form().setValue({email:savedEmail,password:''}) //easier way in the next line
        setTimeout(()=>{this.form().controls['email'].setValue(savedEmail);},1)//setTimeout is workaround
        
      }
      const subscription = this.form().valueChanges?.pipe( debounceTime(500)) //the subscribing funcition will run every 500 ms
      .subscribe({
        next: (value) => window.localStorage.setItem('saved-login-form', JSON.stringify({ email: value.email }))
      });
      this.destroyRef.onDestroy(()=>subscription?.unsubscribe())
    });
    
  }
    
  }
 
 Custom validator for template driven is actually easier
 
ROUTING

/c/AutoFormation/Angular-Ultimate/LearningCode/14-routing/starting-project/01-starting-project

/c/AutoFormation/Angular-Ultimate/LearningCode/14-routing/starting-project-fix

ANG = SPA
but ang allows client-side routing
/user ---> UserComponent
/shop ---> ShopComponent

dynamic parameters

{
      path: 'users/:userId', //your-domain/users/<uid>
      component: UserTasksComponent
    }

import { Component, input } from '@angular/core';

@Component({
  selector: 'app-user-tasks',
  standalone: true,
  templateUrl: './user-tasks.component.html',
  styleUrl: './user-tasks.component.css',
})
export class UserTasksComponent {
  userId = input.required<string>()
}

import { ApplicationConfig } from "@angular/core";
import { provideRouter, withComponentInputBinding } from "@angular/router";

import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
    providers: [ provideRouter(routes, withComponentInputBinding()) ]
}

In case you want to do it old-fashioned
@Input({required: true}) userId!: string;
to run some computed code
@Input()
set userId(uid: string) {
  console.log(uid);
}

alternative way of using input parameters:

import { Component, inject, input, computed, OnInit, DestroyRef } from '@angular/core';
import { UsersService } from '../users.service';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-user-tasks',
  standalone: true,
  templateUrl: './user-tasks.component.html',
  styleUrl: './user-tasks.component.css',
})
export class UserTasksComponent implements OnInit {
  userId = input.required<string>()
  private usersService = inject(UsersService);
  //alternative way
  private activatedRoute = inject(ActivatedRoute)

  userName = computed(()=> this.usersService.users.find(u=>u.id === this.userId())?.name)
  userName2? = ''

  private destroyRef = inject(DestroyRef);

  ngOnInit(): void {
    console.log(this.activatedRoute);
    const subscription = this.activatedRoute.paramMap.subscribe({
      next: (paramMap) => {
        this.userName2 = this.usersService.users.find((u)=>u.id === paramMap.get('userId'))?.name || '';
      } 
    });
    this.destroyRef.onDestroy(()=>subscription.unsubscribe());
  }
}

Nested Routes

export const routes: Routes = [
  {
    path: '', // <your-domain>/
    component: NoTaskComponent,
    // redirectTo: '/users/u1',
    // pathMatch: 'full'
  },
  {
    path: 'users/:userId', // <your-domain>/users/<uid>
    component: UserTasksComponent,
    children: [
      {
        path: '',
        redirectTo: 'tasks',
        pathMatch: 'full'
      },
      {
        path: 'tasks', // <your-domain>/users/<uid>/tasks
        component: TasksComponent,
      },
      {
        path: 'tasks/new',
        component: NewTaskComponent,
      },
    ],
  },
  {
    path: '**',
    component: NotFoundComponent,
  },
];


go one level
<a routerLink="../">Cancel</a>

programmatic navigation
private router = inject(Router);

Spliting files

ActivatedRoute vs Snapshot

ngOnInit(): void {
    console.log('snapshot',this.activatedRoute.snapshot);
    console.log('activated route', this.activatedRoute.paramMap);
    //The difference is the activatedRoute produces subjects while snapshot produces values
    //snapshot is used when you are 100% sure it won't need re-execution
    const subscription = this.activatedRoute.paramMap.subscribe({
      next: (paramMap) => {
        this.userName =
          this.usersService.users.find((u) => u.id === paramMap.get('userId'))
            ?.name || '';
      },
    });

    this.destroyRef.onDestroy(() => subscription.unsubscribe());
  }
  
Query parameters

import { Component, computed, DestroyRef, inject, input, OnInit } from '@angular/core';

import { TaskComponent } from './task/task.component';
import { Task } from './task/task.model';
import { TasksService } from './tasks.service';
import { ActivatedRoute, RouterLink } from '@angular/router';

@Component({
  selector: 'app-tasks',
  standalone: true,
  templateUrl: './tasks.component.html',
  styleUrl: './tasks.component.css',
  imports: [TaskComponent, RouterLink],
})
export class TasksComponent implements OnInit {
  userId = input.required<string>();
  order = input<'asc'|'desc'>(); //same name of query parameter
  private tasksService = inject(TasksService);
  userTasks = computed(() =>
    this.tasksService.allTasks().filter((task) => task.userId === this.userId()).sort((a,b)=>{
      if (this.order() === 'desc')
        return a.id>b.id?-1:1;
      else{
        return a.id>b.id?1:-1;
      }
    })
  );

  //alternative way
  private activatedRoute = inject(ActivatedRoute)
  orderOld?: 'asc' | 'desc';
  private destroyRef = inject(DestroyRef)

  ngOnInit(): void {
    const subscription = this.activatedRoute.queryParams.subscribe({
      next: params=> this.orderOld = params['order']
    });
    this.destroyRef.onDestroy(()=>{ subscription.unsubscribe()})
  }
}

Adding static data

{
    path: 'users/:userId', // <your-domain>/users/<uid>
    component: UserTasksComponent,
    data: { message: 'Hello'},
    children: userRoutes
    // [
    //   {
    //     path: '',
    //     redirectTo: 'tasks',
    //     pathMatch: 'full'
    //   },
    //   {
    //     path: 'tasks', // <your-domain>/users/<uid>/tasks
    //     component: TasksComponent,
    //   },
    //   {
    //     path: 'tasks/new',
    //     component: NewTaskComponent,
    //   },
    // ],
  },
 
Resolve (somewhat like data but dynamic) (Leaner components)

{
    path: 'users/:userId', // <your-domain>/users/<uid>
    component: UserTasksComponent,
    data: { message: 'Hello'},
    resolve : {
      //add a function resolver
      userNameResolve: resolveUserName
    },
    children: userRoutes
    // [
    //   {
    //     path: '',
    //     redirectTo: 'tasks',
    //     pathMatch: 'full'
    //   },
    //   {
    //     path: 'tasks', // <your-domain>/users/<uid>/tasks
    //     component: TasksComponent,
    //   },
    //   {
    //     path: 'tasks/new',
    //     component: NewTaskComponent,
    //   },
    // ],
  },

import {
  Component,
  DestroyRef,
  OnInit,
  computed,
  inject,
  input,
} from '@angular/core';
import { ActivatedRoute, ActivatedRouteSnapshot, ResolveFn, RouterLink, RouterOutlet, RouterStateSnapshot } from '@angular/router';

import { UsersService } from '../users.service';

@Component({
  selector: 'app-user-tasks',
  standalone: true,
  imports: [RouterOutlet, RouterLink],
  templateUrl: './user-tasks.component.html',
  styleUrl: './user-tasks.component.css',
})
export class UserTasksComponent implements OnInit {
  // userId = input.required<string>();
  userName = '';
  private usersService = inject(UsersService);
  private activatedRoute = inject(ActivatedRoute);
  private destroyRef = inject(DestroyRef);

  message = input.required<string>();

  userNameResolve = input.required<string>();

  // userName = computed(
  //   () => this.usersService.users.find((u) => u.id === this.userId())?.name
  // );

  ngOnInit(): void {
    console.log('snapshot',this.activatedRoute.snapshot);
    console.log('activated route', this.activatedRoute.paramMap);
    console.log('Input data',this.message())
    //The difference is the activatedRoute produces subjects while snapshot produces values
    //snapshot is used when you are 100% sure it won't need re-execution
    const subscription = this.activatedRoute.paramMap.subscribe({
      next: (paramMap) => {
        this.userName =
          this.usersService.users.find((u) => u.id === paramMap.get('userId'))
            ?.name || '';
      },
    });

    this.destroyRef.onDestroy(() => subscription.unsubscribe());
  }
}

export const resolveUserName : ResolveFn<string> = (activatedRoute: ActivatedRouteSnapshot, routerState: RouterStateSnapshot)=>{
  const usersService = inject(UsersService);
  const userName = usersService.users.find((u)=>u.id === activatedRoute.paramMap.get('userId'))?.name || ''
  return userName;
}

Alternatively,

@Injectable({ providedIn: 'root' })
export class UserNameResolver implements Resolve<string> {
  constructor(private usersService: UsersService) {}
  resolve(activatedRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    const userName =
      this.usersService.users.find(
        (u) => u.id === activatedRoute.paramMap.get('userId')
      )?.name || '';
    return userName;
  }
}

{
  path: 'users/:userId', // <your-domain>/users/<uid>
  component: UserTasksComponent,
  children: userRoutes,
  data: {
    message: 'Hello!',
  },
  resolve: {
    userName: UserNameResolver,
  },
}

Resolve title

{
    path: 'users/:userId', // <your-domain>/users/<uid>
    component: UserTasksComponent,
    data: { message: 'Hello'},
    resolve : {
      //add a function resolver
      userNameResolve: resolveUserName
    },
    children: userRoutes,
    title: resolveTitle

export const resolveUserName : ResolveFn<string> = (activatedRoute: ActivatedRouteSnapshot, routerState: RouterStateSnapshot)=>{
  const usersService = inject(UsersService);
  const userName = usersService.users.find((u)=>u.id === activatedRoute.paramMap.get('userId'))?.name || ''
  return userName;
}

export const resolveTitle: ResolveFn<string> = (activatedRoute: ActivatedRouteSnapshot, routerState: RouterStateSnapshot)=>{
  return resolveUserName(activatedRoute,routerState) + '\'s tasks'
}

Route Guards

canMatch is more modern
canActivate is more traditional.

const dummyCanMatch: CanMatchFn = (route, segments) => {
  const router = inject(Router)
  const shouldGetAccess = Math.random()
  if (shouldGetAccess < 0.5){
    return true;
  }
  return new RedirectCommand(router.parseUrl('/unauthorized'))
}

export const routes: Routes = [
  {
    path: '', // <your-domain>/
    component: NoTaskComponent,
    // redirectTo: '/users/u1',
    // pathMatch: 'full',
    title: 'No tasks selected'
  },
  {
    path: 'users/:userId', // <your-domain>/users/<uid>
    component: UserTasksComponent,
    data: { message: 'Hello'},
    resolve : {
      //add a function resolver
      userNameResolve: resolveUserName
    },
    children: userRoutes,
    title: resolveTitle,
    canMatch: [dummyCanMatch]
....

Older(deprecaded way)

@Injectable({ providedIn: 'root' })
class CanMatchTeamSection implements CanMatch {
  constructor(private router: Router) {}
  canMatch(route: Route, segments: UrlSegment[]) {
    const shouldGetAccess = Math.random();
    if (shouldGetAccess < 0.5) {
      return true;
    }
    return new RedirectCommand(this.router.parseUrl('/unauthorized'));
  }
}
....

{
  path: 'users/:userId', // <your-domain>/users/<uid>
  component: UserTasksComponent,
  children: userRoutes,
  canMatch: [CanMatchTeamSection],
  data: {
    message: 'Hello!',
  },
  resolve: {
    userName: resolveUserName,
  },
  title: resolveTitle,
},

Deactivate

{
      path: 'tasks/new',
      component: NewTaskComponent,
      canDeactivate: [canLeaveEditPage]
    },
	
export const canLeaveEditPage: CanDeactivateFn<NewTaskComponent> = (component) => {
  if (component.enteredTitle() || component.enteredDate() || component.enteredSummary()){
    window.confirm('Do you really want to leave, yo will lose entered data')
  }
  return true;
}	

VERSION FINALIZADA CON MODULOS

C:\AutoFormation\Angular-Ultimate\LearningCode\14-routing\18-using-ngmodules

LAZY LOADING

Just run the code when needed
Smaller initial bundle size, application is up & running faster.

/c/AutoFormation/Angular-Ultimate/LearningCode/15-lazy-loading/starting-project/01-starting-project

Route-based Lazy LOADING

same import baur the one at the beginning of the file is eager loading while calling import is lazy-loading

const resolveUserTasks: ResolveFn<Task[]> = (
  activatedRouteSnapshot,
  routerState
) => {
  const order = activatedRouteSnapshot.queryParams['order'];
  const tasksService = inject(TasksService);
  const tasks = tasksService
    .allTasks()
    .filter(
      (task) => task.userId === activatedRouteSnapshot.paramMap.get('userId')
    );

  if (order && order === 'asc') {
    tasks.sort((a, b) => (a.id > b.id ? 1 : -1));
  } else {
    tasks.sort((a, b) => (a.id > b.id ? -1 : 1));
  }

  return tasks.length ? tasks : [];
};

export const routes: Routes = [
  {
    path: '',
    redirectTo: 'tasks',
    pathMatch: 'full',
  },
  {
    path: 'tasks', // <your-domain>/users/<uid>/tasks
    //component: TasksComponent,
    //same import baur the one at the beginning of the file is eager loading while calling import is lazy-loading
    loadComponent: () => import('../tasks/tasks.component').then(mod=>mod.TasksComponent),
    runGuardsAndResolvers: 'always',
    resolve: {
      userTasks: resolveUserTasks,
    },
  },

Lazy-loading a group

{
    path: 'users/:userId', // <your-domain>/users/<uid>
    component: UserTasksComponent,
    //children: userRoutes,
    loadChildren: () => { return import('./users/users.routes').then(mod=>mod.routes)},
    canMatch: [dummyCanMatch],
    data: {
      message: 'Hello!',
    },
    resolve: {
      userName: resolveUserName,
    },
    title: resolveTitle,
  },
  
Lazy Loading Services

import { ResolveFn, Routes } from '@angular/router';

import { TasksComponent } from '../tasks/tasks.component';
import { NewTaskComponent, canLeaveEditPage } from '../tasks/new-task/new-task.component';
import { Task } from '../tasks/task/task.model';
import { TasksService } from '../tasks/tasks.service';
import { inject } from '@angular/core';

const resolveUserTasks: ResolveFn<Task[]> = (
  activatedRouteSnapshot,
  routerState
) => {
  const order = activatedRouteSnapshot.queryParams['order'];
  const tasksService = inject(TasksService);
  const tasks = tasksService
    .allTasks()
    .filter(
      (task) => task.userId === activatedRouteSnapshot.paramMap.get('userId')
    );

  if (order && order === 'asc') {
    tasks.sort((a, b) => (a.id > b.id ? 1 : -1));
  } else {
    tasks.sort((a, b) => (a.id > b.id ? -1 : 1));
  }

  return tasks.length ? tasks : [];
};

export const routes: Routes = [
  {
    path: '',
    providers: [TasksService],
    children: 
    [
      {
        path: '',
        redirectTo: 'tasks',
        pathMatch: 'full',
      },
      {
        path: 'tasks', // <your-domain>/users/<uid>/tasks
        component: TasksComponent,
        //same import baur the one at the beginning of the file is eager loading while calling import is lazy-loading
        //loadComponent: () => import('../tasks/tasks.component').then(mod=>mod.TasksComponent),
        //makes sense no more because it's loaded as children at the root routing code
        runGuardsAndResolvers: 'always',
        resolve: {
          userTasks: resolveUserTasks,
        },
      },
      {
        path: 'tasks/new',
        component: NewTaskComponent,
        canDeactivate: [canLeaveEditPage]
      },
    ]
  },  
  
];

import { Injectable, signal } from '@angular/core';

import { type NewTaskData } from './task/task.model';

//@Injectable({ providedIn: 'root' })
@Injectable()
export class TasksService {

Deferrable Views

C:\AutoFormation\Angular-Ultimate\LearningCode\15-lazy-loading\deferrable-views-starting-project

@defer(on viewport) {
  <app-offer-preview />
} @placeholder {
  <p>We might have an offer...</p>
}

....

//when user chlicks
@defer(on interaction) {
  <app-offer-preview />
} @placeholder {
  <p>We might have an offer...</p>
}

@defer(on interaction; prefetch on hover) {
  <app-offer-preview />
} @placeholder {
  <p class="fallback">We might have an offer...</p>
}

DEPLOYMENT

ng serve (generates no right code no optimezed)
(it's only for development not for deployment)

>npm run build
equivalent
>ng build 

Creates /dist/routing/browser folder
Output location: C:\AutoFormation\Angular-Ultimate\LearningCode\16-deployment\starting-project\01-starting-project\dist\routing

Options
1.SPA (Single Page App means client side application) (single.html)
Therefore we don't need any dynamic server (no node.js or php)
Disadvantages: Rendering takes a while.
How to deploy:
https://firebase.google.com/

Create project (ng-deployment-example
Creer/Hosting
>npm install -g firebase-tools
>firebase login
Already logged in as feliperod0519@gmail.com
>firebase init
? What do you want to use as your public directory? dist/routing/browser
? Configure as a single-page app (rewrite all urls to /index.html)? (y/N) y

>npm run build
Check firebase.json for errors such as empty spaces
>firebase deploy

Hosting URL: https://ng-deployment-example-64686.web.app

angular cli for deployment

Option 2. SSR Server Side Rendering
Best of both worlds
routes are rendered on-demand on a dynamic server
Becomes SPA after initial rendering

>ng add @angular/ssr

After creation check server.ts (node.js server)
>ng run build
 Now you will find dist/routing/browser and dist/routing/server
 
 To test 
 >npm run serve:ssr:routing
 
if localstorage errors:
constructor() {
    afterNextRender(()=>{
      const tasks = localStorage.getItem('tasks');

      if (tasks) {
        this.tasks.set(JSON.parse(tasks));
      }
    })
    
  }